TODO #%dot is extensible transformer

(struct posn ((complex x) y))

(define (f (posn p))
 p.x.real-part)

p.x.real-part
(#%dot (#%dot p x) real-part)
(let ([(complex tmp) (posn-x p)])
 (#%dot tmp real-part))

(define (from-origin x) : posn
  (posn x x))

(from-orign 5).x

(begin a (from-origin 5)).x

obj.(move 5 6)

(define (f (cons x y))
 stuff)
(define (f (a-cons p))
 stuff)

(define (f [: b box])
 stuff)
(define (f box.b)
 stuff)
(define (f (box x))
 stuff)

TODO robby's request

(haskell-style
 (f '()) = 0
 (f (cons x l)) = {1+ (f l)})

TODO (define+ (f case) body)

TODO No set! (use data-structure mutation and :=)

(def (var x) 5)
{x := 6}
{x ← 6}

TODO No effects or expressions at top-level (controversial, mf says wrong) [set-once!]

TODO "Versioned" libraries

TODO Make macros less weird and more like programs, by...

TODO Unified matching (syntax-parse/match/etc)

TODO Unified templates (syntax, quasiquote, etc)

  If x is a list, then...

  (template (list (~seq 1 ,x) ...))
  =>
  (append-map (lambda (x) (list 1 x)) x)

  (template (syntax a ,x ... c))
  =>
  (syntax-cons a (syntax-append x (syntax c)))

  (template (+ (f ,x) ...))
  =>
  (apply + (map f x))

TODO Pattern matching everywhere

TODO New structs (more reflective information, representation control, sealing)

TODO Implicit units and interfaces (with properties)

TODO Generics everywhere
https://github.com/stamourv/generic-collections

TODO bindings to cooperate with {}

array.[{1 + 1}].(foo)
->
(#%dot array (#%brackets (+ 1 1)) (foo))

(define (foo (var x) (~opt y 17) (posn p))
 {x := z + 13}
 {p.x + p.y})

TODO Immutable strings only

TODO "define"-transformers for attaching meta-information to definitions, like documentation, tests, contracts, types, etc

TODO Bindings & keywords everywhere

TODO Less representation contraints

TODO Meaningless eq? semantics

TODO Literate programming and inline docs easily

TODO Optional traditional numbers (num/generic => +)

TODO Optional non-coercing number tower (num/{fl,fx,i32,i64,f32,f64,nat,int,rational,real})
---- TODO with maybe impl (num/*/maybe)
---- TODO with overflow errors impl (num/*/exn)
---- TODO with modulo-X impl (num/*/modulo)
---- TODO with modulo-X & carry impl (num/*/carry)

TODO More unicode!

TODO Unboxed, raw data

TODO Remove multiple values?

TODO Rocket-strength super cut:

  λ.(+ $.0 $.1)

TODO Don't use English in exceptions and have more structured exns
[demo on raco/pkg]

english in error messages is good, but adding a markup language instead of just supporting strings

TODO (Define-default-type Number x y z)
  [for define things too]

TODO zos don't appear to users (switch to interp if no write access)

TODO only use syntax-parse and define-simple-macro

TODO add a threading macro

TODO types and other information in syntax-local-value

TODO support :keyword (and keyword:?)

TODO @literate

TODO @docs

TODO Meta def & def* trans for more expansion (docs and test), static
info (types), and def transformers (types), maybe syntax ---
transformer (can change define to define-syntax/etc) vs expander
(expands to a different syntax) --- no ability to add args to
functions!
--- See https://mail.google.com/mail/u/0/#inbox/1513f480b3313fb2

TODO how to make sure cases of cond/etc are complete?

A bare minimum dynamic solution is to do a module-lift to a test
property that use enumeration to enumerate inputs and that sort of
thing. A bare minimum static solution is to have the data and the
variants and a mapping between cases and the variants. It may require
too much knowledge on the data structure than is Rackety.

TODO operator overloading definitions of + and ones that check the
types for float/int/fixnum/etc

TODO greg's defs
https://github.com/greghendershott/defn
https://github.com/greghendershott/def-jambda

TODO fun def transformer

TODO mac def+ transformer (syntax-parser)

TODO parameterize def* transformer
