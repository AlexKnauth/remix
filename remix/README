DONE @ everywhere

DONE demonstrate how @ everywhere enables non-() macros like datalog

DONE {} particular => (#%braces)

DONE {} infix

DONE [] particular => (#%brackets)

DONE default #%brackets is (let () ....)

DONE . in ids => x.y => (%#dot x y)

TODO #%dot is extensible transformer

(struct posn ((complex x) y))

(define (f (posn p))
 p.x.real-part)

p.x.real-part
(#%dot (#%dot p x) real-part)
(let ([(complex tmp) (posn-x p)])
 (#%dot tmp real-part))

(define (from-origin x) : posn
  (posn x x))

(from-orign 5).x

(begin a (from-origin 5)).x

obj.(move 5 6)

(define (f (cons x y))
 stuff)
(define (f (a-cons p))
 stuff)

(define (f [: b box])
 stuff)
(define (f box.b)
 stuff)
(define (f (box x))
 stuff)

TODO robby's request

(haskell-style
 (f '()) = 0
 (f (cons x l)) = {1+ (f l)})

TODO (define+ (f case) body)

TODO No set! (use data-structure mutation and :=)

(def (var x) 5)
{x := 6}

TODO No effects or expressions at top-level (controversial, mf says wrong) [set-once!]

DONE "Versioned" libraries

TODO Make macros less weird and more like programs, by...

TODO Unified matching (syntax-parse/match/etc)

TODO Unified templates (syntax, quasiquote, etc)

  If x is a list, then...

  (template (list (~seq 1 ,x) ...))
  =>
  (append-map (lambda (x) (list 1 x)) x)

  (template (syntax a ,x ... c))
  =>
  (syntax-cons a (syntax-append x (syntax c)))

  (template (+ (f ,x) ...))
  =>
  (apply + (map f x))

TODO Pattern matching everywhere

TODO New structs (more reflective information, representation control, sealing)

TODO Implicit units and interfaces (with properties)

DONE Bare-bones /base

#lang racket/base
(define BASE-NAMES (namespace-mapped-symbols (make-base-namespace)))
(for ([i (in-list BASE-NAMES)])
  (displayln i))
(displayln (length BASE-NAMES))

returns 1433

TODO Generics everywhere
https://github.com/stamourv/generic-collections

TODO Non-() syntax "mode"

array.[{1 + 1}].(foo)
->
(#%dot array (#%brackets (+ 1 1)) (foo))

(define (foo (var x) (~opt y 17) (posn p))
 {x := z + 13}
 {p.x + p.y})

DONE Implicit nesting in blocks
  
  (def (f x)
   (def y 17)
   (+ x y))

TODO Immutable strings only

TODO Remove letrec weirdness of define?

(def (f x)
 (def [even (λ (x) (odd x))]
      [odd (λ (x) (even x))])
 (even x))

TODO "define"-transformers for attaching meta-information to definitions, like documentation, tests, contracts, types, etc

TODO Bindings & keywords everywhere
---- DONE cond

TODO Less representation contraints

TODO Meaningless eq? semantics

TODO Literate programming and inline docs easily

DONE No case-lambda

TODO Optional traditional numbers (num/generic => +)

TODO Optional non-coercing number tower (num/{fl,fx,i32,i64,f32,f64,nat,int,rational,real})
---- TODO with maybe impl (num/*/maybe)
---- TODO with overflow errors impl (num/*/exn)
---- TODO with modulo-X impl (num/*/modulo)
---- TODO with modulo-X & carry impl (num/*/carry)

TODO More unicode!

TODO Unboxed, raw data

TODO Remove multiple values?

TODO Rocket-strength super cut:

  λ.(+ $0 $1)

TODO Don't use English in exceptions and have more structured exns [demo on raco/pkg]

TODO (Define-default-type Number x y z)
  [for define things too]

TODO zos don't appear to users (switch to interp if no write access)

