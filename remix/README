- @ everywhere

- {} infix

- [] particular => (#%brackets )

- . in ids => x.y => (%#dot x y)

(struct posn ((complex x) y))

(define (f (posn p))
 p.x.real-part)

p.x.real-part
(#%dot (#%dot p x) real-part)
(let ([(complex tmp) (posn-x p)])
 (#%dot tmp real-part))

(define (from-origin x) : posn
  (posn x x))

(from-orign 5).x

(begin a (from-origin 5)).x

obj.(move 5 6)

(define (f (cons x y))
 stuff)
(define (f (a-cons p))
 stuff)

(define (f [: b box])
 stuff)
(define (f box.b)
 stuff)
(define (f (box x))
 stuff)

- robby's request
(haskell-style
 (f '()) = 0
 (f (cons x l)) = {1+ (f l)})



- No set! (use data-structure mutation and :=)

(def (var x) 5)
{x := 6}

- No effects or expressions at top-level (controversial, mf says wrong) [set-once!]
- "Versioned" libraries
- Make macros less weird and more like programs, by...
- Unified matching (syntax-parse/match/etc)
- Unified templates (syntax, quasiquote, etc)

  If x is a list, then...

  (template (list (~seq 1 ,x) ...))
  =>
  (append-map (lambda (x) (list 1 x)) x)

  (template (syntax a ,x ... c))
  =>
  (syntax-cons a (syntax-append x (syntax c)))

  (template (+ (f ,x) ...))
  =>
  (apply + (map f x))

- Pattern matching everywhere
- New structs (more reflective information, representation control, sealing)
- Implicit units and interfaces (with properties)
- Bare-bones /base

#lang racket/base
(define BASE-NAMES (namespace-mapped-symbols (make-base-namespace)))
(for ([i (in-list BASE-NAMES)])
  (displayln i))
(displayln (length BASE-NAMES))

returns 1433

- Generics everywhere
https://github.com/stamourv/generic-collections
- Non-() syntax "mode"

array.[{1 + 1}].(foo)
->
(#%dot array (#%brackets (+ 1 1)) (foo))

(define (foo (var x) (~opt y 17) (posn p))
 {x := z + 13}
 {p.x + p.y})

- Implicit nesting in blocks
  
  (def (f x)
   (def y 17)
   (+ x y))

- Immutable strings only
- Remove letrec weirdness of define?

(def (f x)
 (def [even (λ (x) (odd x))]
      [odd (λ (x) (even x))])
 (even x))

- "define"-transformers for attaching meta-information to definitions, like documentation, tests, contracts, types, etc
- Bindings & keywords everywhere
- Less representation contraints
- Meaningless eq? semantics
- Literate programming and inline docs easily
- No case-lambda
- Optional traditional numbers (num/generic => +)
- Optional non-coercing number tower (num/{fl,fx,i32,i64,f32,f64,nat,int,rational,real})
-- with maybe impl (num/*/maybe)
-- with overflow errors impl (num/*/exn)
-- with modulo-X impl (num/*/modulo)
-- with modulo-X & carry impl (num/*/carry)
- More unicode!
- Unboxed, raw data
- Remove multiple values?
- Rocket-strength super cut:

  λ.(+ $0 $1)

- Don't use English in exceptions and have more structured exns [demo on raco/pkg]

- (Define-default-type Number x y z)
  [for define things too]

- zos don't appear to users (switch to interp if no write access)

- (define+ (f case) body)
